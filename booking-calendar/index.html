<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>Dual Calendar with Actions</title>
        <style>
            :root {
                --primary: #4f46e5;
                --accent: #fbbf24;
                --background: #f9fafb;
                --text: #111827;
                --disabled: #d1d5db;
                --today: #3b82f6;
                --selected: #8b5cf6;
                --weekend-bg: #fef2f2;
                --green: #10b981;
                --green-dark: #047857;
                --red: #ef4444;
                --blue: #3b82f6;
                --grey: #6b7280;
                --violet: #8b5cf6;
                --yellow: #f59e0b;
            }

            body {
                margin: 0;
                font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
                background: var(--background);
                color: var(--text);
            }

            .container {
                display: flex;
                flex-wrap: wrap;
                min-height: 100vh;
            }

            .side {
                flex: 1 1 100%;
                padding: 1.5rem;
                box-sizing: border-box;
                text-align: center;
            }

            @media (min-width: 768px) {
                .side {
                    flex: 1 1 50%;
                    border-right: 1px solid #e5e7eb;
                }

                .side:last-child {
                    border-right: none;
                }
            }

            .title {
                font-size: 1.5rem;
                margin-bottom: 1rem;
                font-weight: 600;
                text-align: center;
            }

            .calendar {
                background: white;
                border-radius: 12px;
                padding: 1rem;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
                max-width: 400px;
                margin: 0 auto 1rem auto;
            }

            .calendar-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 1rem;
            }

            .calendar-header button {
                background: var(--primary);
                color: white;
                border: none;
                padding: 0.3rem 0.6rem;
                border-radius: 6px;
                font-size: 0.9rem;
                cursor: pointer;
            }

            .calendar-header button:disabled {
                background: var(--disabled);
                cursor: not-allowed;
            }

            .calendar-header div {
                font-weight: 600;
                font-size: 1rem;
            }

            .calendar-grid {
                display: grid;
                grid-template-columns: repeat(7, 1fr);
                gap: 0.4rem;
            }

            .day-name {
                text-align: center;
                font-weight: 600;
                font-size: 0.85rem;
                color: var(--text); /* Default to dark color for all day names */
            }

            .day-name.weekend-text {
                color: var(--red); /* Override for weekend day names */
            }

            .day {
                text-align: center;
                padding: 0.6rem;
                border-radius: 8px;
                cursor: pointer;
                background: var(--background);
                font-weight: 500;
            }

            .day:hover:not(.disabled):not(.selected):not(.green-marked):not(.yellow-marked) {
                background: #e5e7eb;
            }

            .today {
                background: var(--today);
                color: white;
                font-weight: bold;
            }

            .selected {
                border-style: solid;
                border-color: var(--selected);
                color: white;
            }

            /* New rule for red weekend day numbers */
            .day.weekend-day-number {
                color: var(--red);
            }

            /* Ensure selected and disabled states override the red weekend number */
            .day.selected.weekend-day-number,
            .day.selected {
                color: var(--text); /* Selected days always white text */
            }

            .day.disabled,
            .day.disabled .weekend-day-number {
                /* Ensure disabled days have grey text */
                color: #9ca3af;
                cursor: not-allowed;
            }
            .day.disabled:hover {
                background: var(--background); /* Keep background same for disabled on hover */
            }

            .weekend {
                background-color: var(--weekend-bg);
            }

            .weekend:hover:not(.disabled):not(.selected):not(.green-marked):not(.yellow-marked) {
                background-color: #fbd5d5;
            }

            .day.next-month-day {
                color: var(--disabled);
                background: #f4f5f7;
            }

            .weekend.selected {
                border-style: solid;
                border-color: var(--selected);
                color: white;
            }

            /* New styles for marked days */
            .day.green-marked {
                background-color: var(--green);
                color: white;
            }

            .day.green-marked:hover:not(.selected) {
                background-color: var(--green-dark);
            }

            .day.yellow-marked {
                background-color: var(--yellow);
                color: white;
            }

            .day.yellow-marked:hover:not(.selected) {
                background-color: #d97706; /* Darker yellow on hover */
            }

            /* Prioritize selected over marked */
            .day.green-marked.selected,
            .day.yellow-marked.selected {
                border-style: solid;
                border-color: var(--selected);
                color: white;
            }

            .buttons {
                display: flex;
                flex-wrap: wrap;
                justify-content: center;
                gap: 0.4rem;
            }

            .buttons button {
                padding: 0.4rem 0.8rem;
                border: none;
                border-radius: 6px;
                font-size: 0.85rem;
                color: white;
                cursor: pointer;
            }

            .btn-yellow {
                background-color: var(--accent);
            }
            .btn-blue {
                background-color: var(--blue);
            }
            .btn-green {
                background-color: var(--green);
            }
            .btn-grey {
                background-color: var(--grey);
            }
            .btn-red {
                background-color: var(--red);
            }
            .btn-violet {
                background-color: var(--violet);
            }
            .btn-green-dark {
                background-color: var(--green-dark);
            }

            /* New styles for date range inputs */
            .date-range-controls {
                margin-top: 1rem;
                display: flex;
                flex-wrap: wrap;
                justify-content: center;
                gap: 0.5rem;
                align-items: center;
                padding: 0.5rem;
                border-radius: 8px;
                background-color: white;
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.03);
            }

            .date-range-controls label {
                font-size: 0.9rem;
                font-weight: 500;
                color: var(--text);
            }

            .date-range-controls input[type="date"] {
                padding: 0.4rem;
                border: 1px solid #d1d5db;
                border-radius: 6px;
                font-size: 0.9rem;
                color: var(--text);
                flex-grow: 1; /* Allow inputs to grow */
                max-width: 150px; /* Max width for inputs */
            }

            .date-range-controls button {
                padding: 0.4rem 0.8rem;
                border: none;
                border-radius: 6px;
                font-size: 0.85rem;
                color: white;
                cursor: pointer;
                background-color: var(--blue); /* Using existing blue for apply button */
            }

            /* Styles for time slots */
            .time-slots-container {
                margin-top: 1rem;
                padding: 1rem;
                background: white;
                border-radius: 12px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
                max-width: 100%;
                margin-left: auto;
                margin-right: auto;
                text-align: left;
            }

            .time-slots-container h3 {
                text-align: center;
                margin-bottom: 1rem;
                color: var(--primary);
            }

            .time-slots-grid {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
                gap: 0.5rem;
            }

            .time-slot {
                padding: 0.5rem;
                border: 1px solid var(--primary);
                border-radius: 6px;
                text-align: center;
                cursor: pointer;
                background-color: var(--background);
                color: var(--text);
                font-weight: 500;
            }

            .time-slot:hover:not(.selected-time):not(.green-marked-time):not(.yellow-marked-time) {
                background-color: var(--primary);
                color: white;
            }

            .time-slot.selected-time {
                background-color: var(--selected);
                color: white;
                border-color: var(--selected);
            }

            /* New styles for marked time slots */
            .time-slot.green-marked-time {
                background-color: var(--green);
                color: white;
                border-color: var(--green);
            }
            .time-slot.green-marked-time:hover:not(.selected-time) {
                background-color: var(--green-dark);
                border-color: var(--green-dark);
            }

            .time-slot.yellow-marked-time {
                background-color: var(--yellow);
                color: white;
                border-color: var(--yellow);
            }
            .time-slot.yellow-marked-time:hover:not(.selected-time) {
                background-color: #d97706; /* Darker yellow on hover */
                border-color: #d97706;
            }

            /* Prioritize selected over marked time slots */
            .time-slot.green-marked-time.selected-time {
                border-style: solid;
                border-width: 3px; /* 3px thickness */
                border-color: var(--violet); /* Violet border */
                background-color: var(--green); /* Retain green background */
                color: white;
            }

            .time-slot.yellow-marked-time.selected-time {
                border-style: solid;
                border-width: 3px; /* 3px thickness */
                border-color: var(--violet); /* Violet border */
                background-color: var(--yellow); /* Retain yellow background */
                color: white;
            }

            .day-time-slot-group {
                margin-bottom: 1rem;
                border-top: 1px solid #eee;
                padding-top: 0.5rem;
            }

            .day-time-slot-group:first-child {
                border-top: none;
                padding-top: 0;
            }

            .day-time-slot-group h4 {
                margin-top: 0.5rem;
                margin-bottom: 0.8rem;
                color: var(--blue);
                text-align: left;
            }

            /* New styles for the saved/available times table */
            .saved-times-container,
            .available-times-container {
                margin-top: 1rem;
                padding: 1rem;
                background: white;
                border-radius: 12px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
                max-width: 100%;
                margin-left: auto;
                margin-right: auto;
                text-align: left;
            }

            .saved-times-container h3,
            .available-times-container h3 {
                text-align: center;
                margin-bottom: 1rem;
                color: var(--primary);
            }

            .saved-times-table,
            .available-times-table {
                width: 100%;
                border-collapse: collapse;
                margin-top: 1rem;
            }

            .saved-times-table th,
            .saved-times-table td,
            .available-times-table th,
            .available-times-table td {
                border: 1px solid #e5e7eb;
                padding: 0.6rem 0.8rem;
                text-align: left;
                font-size: 0.9rem;
            }

            .saved-times-table th,
            .available-times-table th {
                background-color: var(--primary);
                color: white;
                font-weight: 600;
            }

            .saved-times-table tr:nth-child(even),
            .available-times-table tr:nth-child(even) {
                background-color: #f9fafb;
            }

            .available-times-table td:first-child {
                text-align: center;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div class="side">
                <div class="title">General</div>
                <div class="calendar" id="calendar-left"></div>
                <div class="buttons">
                    <button class="btn-yellow">Calculate Price</button>
                    <button class="btn-blue">Book Reservation</button>
                    <button class="btn-green" id="show-available-times-left">Show Available Dates and Times</button>
                    <button class="btn-grey" id="reset-left">Reset Selection</button>
                    <button class="btn-grey" id="deselect-time-left">Deselect time</button>
                </div>
                <div class="date-range-controls">
                    <label for="start-date-left">From:</label>
                    <input type="date" id="start-date-left" />
                    <label for="end-date-left">To:</label>
                    <input type="date" id="end-date-left" />
                    <button id="apply-range-left">Apply Range</button>
                </div>
                <div class="time-slots-container" id="time-slots-left"></div>
                <div class="available-times-container" id="available-times-left"></div>
            </div>
            <div class="side">
                <div class="title">Service Providers</div>
                <div class="calendar" id="calendar-right"></div>
                <div class="buttons">
                    <button class="btn-green" id="enable-day-right">Enable Day</button>
                    <button class="btn-green" id="enable-time-right">Enable Time</button>
                    <button class="btn-grey" id="disable-day-right">Disable Day</button>
                    <button class="btn-grey" id="disable-time-right">Disable Time</button>
                    <button class="btn-yellow" id="enable-busy-day-right">Enable Busy Day</button>
                    <button class="btn-yellow" id="enable-busy-time-right">Enable Busy Time</button>
                    <button class="btn-blue">Edit</button>
                    <button class="btn-red">Delete</button>
                    <button class="btn-violet">Cancel</button>
                    <button class="btn-green-dark">Accept</button>
                    <button class="btn-grey" id="reset-right">Reset Selection</button>
                    <button class="btn-grey" id="deselect-time-right">Deselect time</button>
                </div>
                <div class="date-range-controls">
                    <label for="start-date-right">From:</label>
                    <input type="date" id="start-date-right" />
                    <label for="end-date-right">To:</label>
                    <input type="date" id="end-date-right" />
                    <button id="apply-range-right">Apply Range</button>
                </div>
                <div class="time-slots-container" id="time-slots-right"></div>
                <div class="saved-times-container" id="saved-times-right"></div>
            </div>
        </div>

        <script>
            // Utility function to format dates as YYYY-MM-DD
            function getFormattedDate(date) {
                const year = date.getUTCFullYear(); // Use UTC methods
                const month = (date.getUTCMonth() + 1).toString().padStart(2, "0");
                const day = date.getUTCDate().toString().padStart(2, "0");
                return `${year}-${month}-${day}`;
            }

            // Utility function to parse YYYY-MM-DD string to Date object (UTC)
            function parseDateString(dateString) {
                const [year, month, day] = dateString.split("-").map(Number);
                // Create Date object using UTC constructor for consistency
                return new Date(Date.UTC(year, month - 1, day));
            }

            // Utility function to group consecutive time slots into ranges
            function groupTimeSlotsIntoRanges(timeSlots) {
                if (timeSlots.length === 0) {
                    return [];
                }

                const sortedTimes = Array.from(timeSlots).sort();
                const ranges = [];
                let currentRangeStart = sortedTimes[0];
                let prevTime = sortedTimes[0];

                for (let i = 1; i < sortedTimes.length; i++) {
                    const currentTime = sortedTimes[i];
                    // Check if currentTime is exactly 30 minutes after prevTime
                    const prevHour = parseInt(prevTime.substring(0, 2));
                    const prevMinute = parseInt(prevTime.substring(3, 5));
                    const currentHour = parseInt(currentTime.substring(0, 2));
                    const currentMinute = parseInt(currentTime.substring(3, 5));

                    const prevTotalMinutes = prevHour * 60 + prevMinute;
                    const currentTotalMinutes = currentHour * 60 + currentMinute;

                    if (currentTotalMinutes - prevTotalMinutes === 30) {
                        prevTime = currentTime;
                    } else {
                        // End of a consecutive range
                        if (currentRangeStart === prevTime) {
                            ranges.push(currentRangeStart);
                        } else {
                            ranges.push(`${currentRangeStart}-${prevTime}`);
                        }
                        currentRangeStart = currentTime;
                        prevTime = currentTime;
                    }
                }

                // Add the last range
                if (currentRangeStart === prevTime) {
                    ranges.push(currentRangeStart);
                } else {
                    ranges.push(`${currentRangeStart}-${prevTime}`);
                }

                return ranges;
            }

            class Calendar {
                constructor(
                    containerId,
                    startDateInputId,
                    endDateInputId,
                    applyButtonId,
                    resetButtonId,
                    deselectTimeButtonId, // New parameter for deselect time button
                    timeSlotsContainerId,
                    isServiceProviderCalendar = false // New parameter to differentiate calendars
                ) {
                    this.container = document.getElementById(containerId);
                    this.startDateInput = document.getElementById(startDateInputId);
                    this.endDateInput = document.getElementById(endDateInputId);
                    this.applyButton = document.getElementById(applyButtonId);
                    this.resetButton = document.getElementById(resetButtonId);
                    this.deselectTimeButton = document.getElementById(deselectTimeButtonId); // Get the deselect time button
                    this.timeSlotsContainer = document.getElementById(timeSlotsContainerId);
                    this.isServiceProviderCalendar = isServiceProviderCalendar;
                    this.savedTimesContainer = null; // Will be initialized if service provider calendar
                    this.availableTimesContainer = null; // Will be initialized if general calendar

                    // Initialize currentDate using UTC components of 'now' for consistent internal state
                    const now = new Date();
                    this.currentDate = new Date(Date.UTC(now.getFullYear(), now.getMonth(), 1));

                    this.selectedDates = new Set(); // Each calendar has its own set of selected dates (formatted YYYY-MM-DD strings)
                    this.selectedTimeSlots = new Map(); // Map: 'YYYY-MM-DD' -> Set<timeString>
                    this.firstClickedDate = null; // Stores the Date object of the first click for range selection

                    // New sets and maps for marking days/times
                    this.greenMarkedDates = new Set();
                    this.yellowMarkedDates = new Set();
                    this.greenMarkedTimeSlots = new Map(); // 'YYYY-MM-DD' -> Set<timeString>
                    this.yellowMarkedTimeSlots = new Map(); // 'YYYY-MM-DD' -> Set<timeString>

                    // New storage for enabled time slots (for Service Provider calendar)
                    this.enabledTimeSlotsData = new Map(); // Map: 'YYYY-MM-DD' -> Set<timeString>

                    this.todayFormatted = getFormattedDate(
                        new Date(Date.UTC(now.getFullYear(), now.getMonth(), now.getDate()))
                    );

                    this.render(); // Initial render
                    this.addRangeInputListeners(); // Add listeners for the new range inputs
                    this.addDelegatedDayClickListeners(); // Add delegated listener for day clicks
                    this.addResetButtonListener(); // Add listener for the reset button
                    this.addDeselectTimeButtonListener(); // Add listener for the deselect time button
                    this.setMinDatesForInputs(); // Set initial min dates for date inputs
                    this.renderTimeSlots(); // Initial render of time slots container (empty)

                    if (this.isServiceProviderCalendar) {
                        this.addServiceProviderButtonListeners();
                        this.savedTimesContainer = document.getElementById("saved-times-right");
                        this.renderSavedTimesTable(); // Initial render of the saved times table
                    } else {
                        this.availableTimesContainer = document.getElementById("available-times-left");
                        this.addGeneralButtonListeners(); // Add listeners for General calendar buttons
                    }
                }

                setMinDatesForInputs() {
                    this.startDateInput.min = this.todayFormatted;
                    this.endDateInput.min = this.todayFormatted;
                }

                render() {
                    // Create 'now' Date object in UTC for consistent comparisons
                    const now = new Date();
                    const nowUTC = new Date(Date.UTC(now.getFullYear(), now.getMonth(), now.getDate()));

                    const year = this.currentDate.getUTCFullYear(); // Use UTC methods
                    const month = this.currentDate.getUTCMonth(); // Use UTC methods
                    const firstDay = new Date(Date.UTC(year, month, 1));
                    const lastDay = new Date(Date.UTC(year, month + 1, 0));
                    const daysInMonth = lastDay.getUTCDate(); // Use UTC method

                    let startDay = (firstDay.getUTCDay() + 6) % 7; // Adjust to make Monday the first day (0-6 -> Mon-Sun)

                    this.container.innerHTML = `
                        <div class="calendar-header">
                            <button class="prev">&lt;</button>
                            <div>${this.currentDate.toLocaleString("default", {
                                month: "long",
                                year: "numeric",
                                timeZone: "UTC",
                            })}</div>
                            <button class="next">&gt;</button>
                        </div>
                        <div class="calendar-grid"></div>
                    `;

                    const grid = this.container.querySelector(".calendar-grid");
                    const dayNames = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
                    dayNames.forEach((d, index) => {
                        const el = document.createElement("div");
                        el.className = "day-name";
                        if (index === 5 || index === 6) {
                            // Saturday (5) and Sunday (6)
                            el.classList.add("weekend-text");
                        }
                        el.textContent = d;
                        grid.appendChild(el);
                    });

                    // Fill leading empty days
                    for (let i = 0; i < startDay; i++) {
                        const empty = document.createElement("div");
                        grid.appendChild(empty);
                    }

                    // Render days of the current month
                    for (let day = 1; day <= daysInMonth; day++) {
                        const el = document.createElement("div");
                        el.className = "day";
                        el.textContent = day;

                        const cellDate = new Date(Date.UTC(year, month, day)); // Create Date object for cell in UTC
                        const cellDayOfWeek = (cellDate.getUTCDay() + 6) % 7; // 0=Mon, 1=Tue, ..., 5=Sat, 6=Sun
                        const isPast = cellDate.getTime() < nowUTC.getTime(); // Compare UTC dates using getTime()
                        const formattedCellDate = getFormattedDate(cellDate);

                        // Store the formatted date directly on the element for easy retrieval via event delegation
                        el.dataset.date = formattedCellDate;

                        if (cellDayOfWeek === 5 || cellDayOfWeek === 6) {
                            // Saturday or Sunday
                            el.classList.add("weekend", "weekend-day-number"); // Add weekend-day-number for red text
                        }

                        if (isPast) {
                            el.classList.add("disabled");
                        }

                        if (
                            cellDate.getUTCFullYear() === nowUTC.getUTCFullYear() &&
                            cellDate.getUTCMonth() === nowUTC.getUTCMonth() &&
                            cellDate.getUTCDate() === nowUTC.getUTCDate()
                        ) {
                            el.classList.add("today");
                        }

                        // Apply green-marked or yellow-marked class if applicable
                        if (this.greenMarkedDates.has(formattedCellDate)) {
                            el.classList.add("green-marked");
                        } else if (this.yellowMarkedDates.has(formattedCellDate)) {
                            el.classList.add("yellow-marked");
                        }

                        // Check if this day is selected for THIS calendar (selected always overrides marked colors)
                        if (this.selectedDates.has(formattedCellDate)) {
                            el.classList.add("selected");
                        }

                        grid.appendChild(el);
                    }

                    // Add days from the next month to fill the grid
                    const totalDaysDisplayed = startDay + daysInMonth;
                    let fillerDayCount = 0;

                    if (totalDaysDisplayed < 35) {
                        fillerDayCount = 35 - totalDaysDisplayed;
                    } else if (totalDaysDisplayed < 42) {
                        fillerDayCount = 42 - totalDaysDisplayed;
                    }

                    for (let day = 1; day <= fillerDayCount; day++) {
                        const el = document.createElement("div");
                        el.className = "day next-month-day";
                        el.textContent = day;

                        const nextMonthDate = new Date(Date.UTC(year, month + 1, day)); // Create UTC date
                        const formattedNextMonthDate = getFormattedDate(nextMonthDate);

                        // Store the formatted date directly on the element for easy retrieval
                        el.dataset.date = formattedNextMonthDate;

                        const cellDayOfWeek = (nextMonthDate.getUTCDay() + 6) % 7; // Get day of week for next month's day in UTC

                        if (cellDayOfWeek === 5 || cellDayOfWeek === 6) {
                            // Saturday or Sunday in the next month
                            el.classList.add("weekend", "weekend-day-number"); // Add weekend-day-number for red text
                        }

                        // Apply green-marked or yellow-marked class if applicable for next month days
                        if (this.greenMarkedDates.has(formattedNextMonthDate)) {
                            el.classList.add("green-marked");
                        } else if (this.yellowMarkedDates.has(formattedNextMonthDate)) {
                            el.classList.add("yellow-marked");
                        }

                        // Check if this next month day is selected for THIS calendar (selected always overrides marked colors)
                        if (this.selectedDates.has(formattedNextMonthDate)) {
                            el.classList.add("selected");
                        }

                        grid.appendChild(el);
                    }

                    // After rendering the new buttons, attach their event listeners, including delegated day clicks
                    this.addEventListeners();
                    this.addDelegatedDayClickListeners(); // Ensure this is called after the grid is rendered

                    // Disable previous button if at current month (using UTC components)
                    const prevButton = this.container.querySelector(".prev");
                    if (
                        this.currentDate.getUTCFullYear() === nowUTC.getUTCFullYear() &&
                        this.currentDate.getUTCMonth() === nowUTC.getUTCMonth()
                    ) {
                        prevButton.disabled = true;
                    } else {
                        prevButton.disabled = false;
                    }

                    this.updateDateInputs(); // Update the input fields after rendering
                    this.renderTimeSlots(); // Re-render time slots based on updated selected dates
                }

                addEventListeners() {
                    // Remove any existing listeners first to prevent duplicates by cloning nodes
                    const prevButton = this.container.querySelector(".prev");
                    const nextButton = this.container.querySelector(".next");

                    const newPrevButton = prevButton.cloneNode(true);
                    const newNextButton = nextButton.cloneNode(true);

                    prevButton.parentNode.replaceChild(newPrevButton, prevButton);
                    nextButton.parentNode.replaceChild(newNextButton, nextButton);

                    // Re-attach event listeners to the new buttons
                    newPrevButton.addEventListener("click", () => {
                        const now = new Date();
                        const nowUTC = new Date(Date.UTC(now.getFullYear(), now.getMonth(), now.getDate()));
                        // Prevent going back before the current month (using UTC components)
                        if (
                            this.currentDate.getUTCFullYear() > nowUTC.getUTCFullYear() ||
                            (this.currentDate.getUTCFullYear() === nowUTC.getUTCFullYear() &&
                                this.currentDate.getUTCMonth() > nowUTC.getUTCMonth())
                        ) {
                            this.currentDate.setUTCMonth(this.currentDate.getUTCMonth() - 1);
                            this.render();
                        }
                    });

                    newNextButton.addEventListener("click", () => {
                        this.currentDate.setUTCMonth(this.currentDate.getUTCMonth() + 1);
                        this.render();
                    });
                }

                /**
                 * Attaches a single delegated click listener to the calendar grid for all day elements.
                 * This listener will persist even when the grid content is re-rendered.
                 */
                addDelegatedDayClickListeners() {
                    const calendarGrid = this.container.querySelector(".calendar-grid");

                    // Define the handler function once in the constructor if not already defined
                    if (!this._dayClickHandler) {
                        this._dayClickHandler = (event) => {
                            const clickedDayElement = event.target.closest(".day");

                            if (clickedDayElement && !clickedDayElement.classList.contains("disabled")) {
                                const formattedDate = clickedDayElement.dataset.date;

                                // If a next-month-day was clicked, we need to first navigate to that month
                                if (clickedDayElement.classList.contains("next-month-day")) {
                                    const nextMonthDate = parseDateString(formattedDate);
                                    this.currentDate = new Date(
                                        Date.UTC(nextMonthDate.getUTCFullYear(), nextMonthDate.getUTCMonth(), 1)
                                    );
                                }

                                this.handleDayClick(formattedDate);
                            }
                        };
                    }

                    // Remove previous listener instance if it exists (important for re-renders)
                    if (calendarGrid) {
                        calendarGrid.removeEventListener("click", this._dayClickHandler);
                        calendarGrid.addEventListener("click", this._dayClickHandler);
                    }
                }

                /**
                 * Handles a click on a day cell to implement single day or range selection, and unselection.
                 * If a day within an existing range is clicked, it clears the current range and starts a new single-day selection.
                 * @param {string} formattedDate The 'YYYY-MM-DD' string of the clicked date.
                 */
                handleDayClick(formattedDate) {
                    const clickedDate = parseDateString(formattedDate);
                    const now = new Date();
                    const nowUTC = new Date(Date.UTC(now.getFullYear(), now.getMonth(), now.getDate()));

                    if (clickedDate.getTime() < nowUTC.getTime()) {
                        // Should already be disabled, but a safety check for clicks.
                        alert("Cannot select a past date.");
                        return;
                    }

                    if (!this.firstClickedDate) {
                        // This is the very first click or after a reset. Select this date as the start of a range.
                        this.selectedDates.clear();
                        this.selectedDates.add(formattedDate);
                        this.firstClickedDate = clickedDate;
                    } else {
                        // This is the second click for a potential range selection.
                        const secondDate = clickedDate;

                        if (secondDate.getTime() < this.firstClickedDate.getTime()) {
                            // User tried to select a range backwards (e.g., selected 21st, then 19th).
                            // As per cargo.lt behavior, this should reset the selection to the new single date.
                            this.selectedDates.clear();
                            this.selectedDates.add(formattedDate);
                            this.firstClickedDate = clickedDate; // The earlier date becomes the new first clicked date
                        } else {
                            // Valid forward range selection.
                            this.selectedDates.clear();
                            let loopDate = new Date(this.firstClickedDate);
                            while (loopDate.getTime() <= secondDate.getTime()) {
                                this.selectedDates.add(getFormattedDate(loopDate));
                                loopDate.setUTCDate(loopDate.getUTCDate() + 1);
                            }
                            // After completing a range selection, reset firstClickedDate
                            this.firstClickedDate = null;
                        }
                    }
                    this.render(); // Re-render to update the calendar display and input fields
                }

                addRangeInputListeners() {
                    if (this.applyButton) {
                        this.applyButton.addEventListener("click", () => this.handleApplyRange());
                    }
                    // Add input change listeners to update selections
                    if (this.startDateInput) {
                        this.startDateInput.addEventListener("change", () => this.handleDateInputChange());
                    }
                    if (this.endDateInput) {
                        this.endDateInput.addEventListener("change", () => this.handleDateInputChange());
                    }
                }

                addResetButtonListener() {
                    // Add event listener for the reset button
                    if (this.resetButton) {
                        this.resetButton.addEventListener("click", () => this.resetSelection());
                    }
                }

                // New method to handle deselecting all time slots
                addDeselectTimeButtonListener() {
                    if (this.deselectTimeButton) {
                        this.deselectTimeButton.addEventListener("click", () => this.deselectTimeSlots());
                    }
                }

                deselectTimeSlots() {
                    this.selectedTimeSlots.clear(); // Clear all selected time slots
                    this.renderTimeSlots(); // Re-render the time slots display
                }

                handleDateInputChange() {
                    const startDateStr = this.startDateInput.value;
                    const endDateStr = this.endDateInput.value;

                    const now = new Date();
                    const nowUTC = new Date(Date.UTC(now.getFullYear(), now.getMonth(), now.getDate())); // Today's date in UTC

                    // Update endDateInput's min attribute based on startDateInput's value
                    if (startDateStr) {
                        this.endDateInput.min = startDateStr;
                    } else {
                        // If start date is cleared, min for end date reverts to today
                        this.endDateInput.min = this.todayFormatted;
                    }

                    if (startDateStr && endDateStr) {
                        const startDate = parseDateString(startDateStr);
                        const endDate = parseDateString(endDateStr);

                        if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
                            // Invalid date format, just return without changing selection
                            return;
                        }

                        // Check if either date is in the past
                        if (startDate.getTime() < nowUTC.getTime() || endDate.getTime() < nowUTC.getTime()) {
                            alert("Cannot select a past date. Selection reset.");
                            this.resetSelection();
                            return;
                        }

                        if (endDate.getTime() < startDate.getTime()) {
                            // Compare using getTime() for Date objects
                            alert("End date cannot be before start date. Selection reset.");
                            this.resetSelection();
                            return;
                        }
                        this.applyDateRange(startDate, endDate, true); // true to prevent re-rendering if already on correct month
                    } else if (!startDateStr && !endDateStr) {
                        this.resetSelection(); // If both cleared, reset calendar
                    } else {
                        // If only one date is set, consider it a single selection
                        if (startDateStr) {
                            const startDate = parseDateString(startDateStr);
                            if (startDate.getTime() < nowUTC.getTime()) {
                                alert("Cannot select a past date. Selection reset.");
                                this.resetSelection();
                                return;
                            }
                            this.selectedDates.clear();
                            this.selectedDates.add(startDateStr);
                            this.firstClickedDate = null; // Clear firstClickedDate for single selection
                            this.currentDate = new Date(
                                Date.UTC(startDate.getUTCFullYear(), startDate.getUTCMonth(), 1)
                            ); // Move to the selected month
                            this.render();
                        } else if (endDateStr) {
                            // If only end date is set, treat it as a single selection
                            const endDate = parseDateString(endDateStr);
                            if (endDate.getTime() < nowUTC.getTime()) {
                                alert("Cannot select a past date. Selection reset.");
                                this.resetSelection();
                                return;
                            }
                            this.selectedDates.clear();
                            this.selectedDates.add(endDateStr);
                            this.firstClickedDate = null; // Clear firstClickedDate for single selection
                            this.currentDate = new Date(Date.UTC(endDate.getUTCFullYear(), endDate.getUTCMonth(), 1)); // Move to the selected month
                            this.render();
                        }
                    }
                }

                handleApplyRange() {
                    const startDateStr = this.startDateInput.value;
                    const endDateStr = this.endDateInput.value;

                    const now = new Date();
                    const nowUTC = new Date(Date.UTC(now.getFullYear(), now.getMonth(), now.getDate()));

                    if (!startDateStr || !endDateStr) {
                        alert("Please select both start and end dates to apply a range.");
                        return;
                    }

                    const startDate = parseDateString(startDateStr);
                    const endDate = parseDateString(endDateStr);

                    if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
                        alert("Invalid date format. Please use YYYY-MM-DD.");
                        return;
                    }

                    // Check if either date is in the past
                    if (startDate.getTime() < nowUTC.getTime() || endDate.getTime() < nowUTC.getTime()) {
                        alert("Cannot select a past date.");
                        this.resetSelection();
                        return;
                    }

                    if (endDate.getTime() < startDate.getTime()) {
                        alert("End date cannot be before start date.");
                        this.resetSelection();
                        return;
                    }

                    this.applyDateRange(startDate, endDate);
                }

                applyDateRange(startDate, endDate, suppressRender = false) {
                    this.selectedDates.clear();
                    let loopDate = new Date(startDate);
                    while (loopDate.getTime() <= endDate.getTime()) {
                        this.selectedDates.add(getFormattedDate(loopDate));
                        loopDate.setUTCDate(loopDate.getUTCDate() + 1);
                    }
                    this.firstClickedDate = null; // Clear firstClickedDate after range selection
                    // Set calendar to display the start month of the selected range
                    this.currentDate = new Date(Date.UTC(startDate.getUTCFullYear(), startDate.getUTCMonth(), 1));
                    if (!suppressRender) {
                        this.render();
                    } else {
                        // If render is suppressed, ensure the visual selection is updated
                        this.updateCalendarDayClasses();
                        this.renderTimeSlots();
                    }
                }

                updateCalendarDayClasses() {
                    this.container.querySelectorAll(".day").forEach((dayEl) => {
                        const formattedDate = dayEl.dataset.date;
                        // First remove all selection/marking classes
                        dayEl.classList.remove("selected", "green-marked", "yellow-marked");

                        // Apply green-marked or yellow-marked if applicable
                        if (this.greenMarkedDates.has(formattedDate)) {
                            dayEl.classList.add("green-marked");
                        } else if (this.yellowMarkedDates.has(formattedDate)) {
                            dayEl.classList.add("yellow-marked");
                        }

                        // Apply selected class (this will override marked colors visually due to CSS order/specificity)
                        if (this.selectedDates.has(formattedDate)) {
                            dayEl.classList.add("selected");
                        }
                    });
                }

                updateDateInputs() {
                    const sortedSelectedDates = Array.from(this.selectedDates).sort();
                    if (sortedSelectedDates.length > 0) {
                        this.startDateInput.value = sortedSelectedDates[0];
                        this.endDateInput.value = sortedSelectedDates[sortedSelectedDates.length - 1];
                    } else {
                        this.startDateInput.value = "";
                        this.endDateInput.value = "";
                    }
                }

                resetSelection() {
                    this.selectedDates.clear();
                    this.selectedTimeSlots.clear(); // Also clear selected time slots on date reset
                    this.firstClickedDate = null;
                    const now = new Date();
                    this.currentDate = new Date(Date.UTC(now.getFullYear(), now.getMonth(), 1)); // Reset to current month
                    this.render(); // Re-render to clear selection and update inputs
                    this.startDateInput.value = "";
                    this.endDateInput.value = "";
                    // Clear the available times table if it exists
                    if (this.availableTimesContainer) {
                        this.availableTimesContainer.innerHTML = "";
                    }
                }

                // Generates and renders time slots based on the currently selected dates.
                renderTimeSlots() {
                    let html = "<h3>Selected Dates & Times</h3>";

                    if (this.selectedDates.size === 0) {
                        this.timeSlotsContainer.innerHTML = html + "<p>No dates selected yet.</p>";
                        return;
                    }

                    // Sort selected dates to display them in chronological order
                    const sortedDates = Array.from(this.selectedDates).sort();

                    sortedDates.forEach((dateString) => {
                        html += `<div class="day-time-slot-group">`;
                        html += `<h4>${new Date(dateString).toLocaleDateString("en-US", {
                            weekday: "short",
                            year: "numeric",
                            month: "short",
                            day: "numeric",
                            timeZone: "UTC",
                        })}</h4>`;
                        html += `<div class="time-slots-grid">`;

                        // Example time slots - replace with dynamic data as needed
                        const times = ["09:00", "09:30", "10:00", "10:30", "11:00", "11:30", "12:00", "12:30", "13:00", "13:30", "14:00", "14:30", "15:00", "15:30", "16:00", "16:30", "17:00"];

                        times.forEach((time) => {
                            const isSelected =
                                this.selectedTimeSlots.has(dateString) &&
                                this.selectedTimeSlots.get(dateString).has(time);
                            const isGreenMarked =
                                this.greenMarkedTimeSlots.has(dateString) &&
                                this.greenMarkedTimeSlots.get(dateString).has(time);
                            const isYellowMarked =
                                this.yellowMarkedTimeSlots.has(dateString) &&
                                this.yellowMarkedTimeSlots.get(dateString).has(time);

                            let classes = "";
                            if (isSelected) {
                                classes = "selected-time"; // Selected always takes precedence for the base class
                            }

                            if (isGreenMarked) {
                                classes += " green-marked-time";
                            } else if (isYellowMarked) {
                                classes += " yellow-marked-time";
                            }

                            html += `<div class="time-slot ${classes.trim()}" data-date="${dateString}" data-time="${time}">${time}</div>`;
                        });
                        html += `</div></div>`;
                    });

                    this.timeSlotsContainer.innerHTML = html;
                    this.addTimeSlotClickListeners(); // Add listeners after rendering
                }

                // Attaches click listeners to each time slot.
                addTimeSlotClickListeners() {
                    this.timeSlotsContainer.querySelectorAll(".time-slot").forEach((slot) => {
                        slot.addEventListener("click", (event) => {
                            const dateString = event.target.dataset.date;
                            const timeString = event.target.dataset.time;
                            this.toggleTimeSlotSelection(dateString, timeString);
                        });
                    });
                }

                // Toggles the selection state of a time slot.
                toggleTimeSlotSelection(dateString, timeString) {
                    if (!this.selectedTimeSlots.has(dateString)) {
                        this.selectedTimeSlots.set(dateString, new Set());
                    }

                    const timeSet = this.selectedTimeSlots.get(dateString);
                    if (timeSet.has(timeString)) {
                        timeSet.delete(timeString);
                        if (timeSet.size === 0) {
                            this.selectedTimeSlots.delete(dateString); // Remove date if no times selected for it
                        }
                    } else {
                        timeSet.add(timeString);
                    }
                    this.renderTimeSlots(); // Re-render to update UI
                }

                // Service Provider specific actions
                addServiceProviderButtonListeners() {
                    document.getElementById("enable-day-right").addEventListener("click", () => this.enableDay());
                    document.getElementById("enable-time-right").addEventListener("click", () => this.enableTime());
                    document.getElementById("disable-day-right").addEventListener("click", () => this.disableDay());
                    document.getElementById("disable-time-right").addEventListener("click", () => this.disableTime());
                    document
                        .getElementById("enable-busy-day-right")
                        .addEventListener("click", () => this.enableBusyDay());
                    document
                        .getElementById("enable-busy-time-right")
                        .addEventListener("click", () => this.enableBusyTime());
                }

                enableDay() {
                    if (this.selectedDates.size === 0) {
                        alert("Please select at least one day to enable.");
                        return;
                    }
                    this.selectedDates.forEach((date) => {
                        this.greenMarkedDates.add(date);
                        this.yellowMarkedDates.delete(date); // Ensure it's not yellow
                    });
                    this.render();
                }

                disableDay() {
                    if (this.selectedDates.size === 0) {
                        alert("Please select at least one day to disable.");
                        return;
                    }
                    this.selectedDates.forEach((date) => {
                        this.greenMarkedDates.delete(date);
                        this.yellowMarkedDates.delete(date);
                        // Also ensure time slots for this date are not marked
                        this.greenMarkedTimeSlots.delete(date);
                        this.yellowMarkedTimeSlots.delete(date);
                        // Also remove from enabledTimeSlotsData
                        this.enabledTimeSlotsData.delete(date);
                    });
                    this.render();
                    this.renderTimeSlots(); // Update time slot display
                    this.renderSavedTimesTable(); // Update saved times table
                }

                enableBusyDay() {
                    if (this.selectedDates.size === 0) {
                        alert("Please select at least one day to mark as busy.");
                        return;
                    }
                    this.selectedDates.forEach((date) => {
                        this.yellowMarkedDates.add(date);
                        this.greenMarkedDates.delete(date); // Ensure it's not green
                    });
                    this.render();
                }

                enableTime() {
                    if (this.selectedTimeSlots.size === 0) {
                        alert("Please select at least one time slot to enable.");
                        return;
                    }
                    this.selectedTimeSlots.forEach((times, date) => {
                        if (!this.greenMarkedTimeSlots.has(date)) {
                            this.greenMarkedTimeSlots.set(date, new Set());
                        }
                        if (this.yellowMarkedTimeSlots.has(date)) {
                            times.forEach((time) => this.yellowMarkedTimeSlots.get(date).delete(time)); // Remove from yellow
                            if (this.yellowMarkedTimeSlots.get(date).size === 0) {
                                this.yellowMarkedTimeSlots.delete(date);
                            }
                        }
                        times.forEach((time) => this.greenMarkedTimeSlots.get(date).add(time));

                        // Add/Update to enabledTimeSlotsData for this calendar instance
                        if (!this.enabledTimeSlotsData.has(date)) {
                            this.enabledTimeSlotsData.set(date, new Set());
                        }
                        times.forEach((time) => this.enabledTimeSlotsData.get(date).add(time));

                        // Mark the day as green if any time slots are green-marked for it
                        if (this.greenMarkedTimeSlots.has(date) && this.greenMarkedTimeSlots.get(date).size > 0) {
                            this.greenMarkedDates.add(date);
                            this.yellowMarkedDates.delete(date); // Ensure day is not yellow if now green
                        }
                    });
                    this.render(); // Re-render calendar to update day colors
                    this.renderTimeSlots();
                    this.renderSavedTimesTable(); // Update the saved times table
                }

                disableTime() {
                    if (this.selectedTimeSlots.size === 0) {
                        alert("Please select at least one time slot to disable.");
                        return;
                    }
                    this.selectedTimeSlots.forEach((times, date) => {
                        // Create a temporary set of times to disable to avoid modifying 'times' during iteration
                        const timesToDisable = new Set(times);

                        // Remove from green marked times
                        if (this.greenMarkedTimeSlots.has(date)) {
                            timesToDisable.forEach((time) => this.greenMarkedTimeSlots.get(date).delete(time));
                            if (this.greenMarkedTimeSlots.get(date).size === 0) {
                                this.greenMarkedTimeSlots.delete(date);
                            }
                        }
                        // Remove from yellow marked times
                        if (this.yellowMarkedTimeSlots.has(date)) {
                            timesToDisable.forEach((time) => this.yellowMarkedTimeSlots.get(date).delete(time));
                            if (this.yellowMarkedTimeSlots.get(date).size === 0) {
                                this.yellowMarkedTimeSlots.delete(date);
                            }
                        }

                        // Remove from enabledTimeSlotsData
                        if (this.enabledTimeSlotsData.has(date)) {
                            timesToDisable.forEach((time) => this.enabledTimeSlotsData.get(date).delete(time));
                            if (this.enabledTimeSlotsData.get(date).size === 0) {
                                this.enabledTimeSlotsData.delete(date);
                            }
                        }

                        // Check if the day should no longer be marked green or yellow
                        if (!this.greenMarkedTimeSlots.has(date) || this.greenMarkedTimeSlots.get(date).size === 0) {
                            this.greenMarkedDates.delete(date);
                        }
                        if (!this.yellowMarkedTimeSlots.has(date) || this.yellowMarkedTimeSlots.get(date).size === 0) {
                            this.yellowMarkedDates.delete(date);
                        }
                    });
                    this.render(); // Re-render calendar to update day colors
                    this.renderTimeSlots();
                    this.renderSavedTimesTable(); // Update the saved times table
                }

                enableBusyTime() {
                    if (this.selectedTimeSlots.size === 0) {
                        alert("Please select at least one time slot to mark as busy.");
                        return;
                    }
                    this.selectedTimeSlots.forEach((times, date) => {
                        if (!this.yellowMarkedTimeSlots.has(date)) {
                            this.yellowMarkedTimeSlots.set(date, new Set());
                        }
                        if (this.greenMarkedTimeSlots.has(date)) {
                            times.forEach((time) => this.greenMarkedTimeSlots.get(date).delete(time)); // Remove from green
                            if (this.greenMarkedTimeSlots.get(date).size === 0) {
                                this.greenMarkedTimeSlots.delete(date);
                            }
                        }
                        times.forEach((time) => this.yellowMarkedTimeSlots.get(date).add(time));

                        // Mark the day as yellow if any time slots are yellow-marked for it
                        if (this.yellowMarkedTimeSlots.has(date) && this.yellowMarkedTimeSlots.get(date).size > 0) {
                            this.yellowMarkedDates.add(date);
                            this.greenMarkedDates.delete(date); // Ensure day is not green if now yellow
                        }
                    });
                    this.render(); // Re-render calendar to update day colors
                    this.renderTimeSlots();
                    this.renderSavedTimesTable(); // Update the saved times table
                }

                // New method to render the table of saved/enabled times for Service Providers
                renderSavedTimesTable() {
                    if (!this.savedTimesContainer) {
                        return; // Only for Service Provider calendar
                    }

                    let html = "<h3>Enabled Dates & Time Ranges</h3>";

                    if (this.enabledTimeSlotsData.size === 0) {
                        this.savedTimesContainer.innerHTML = html + "<p>No enabled dates/times.</p>";
                        return;
                    }

                    html += `<table class="saved-times-table">
                                <thead>
                                    <tr>
                                        <th>No.</th>
                                        <th>Date</th>
                                        <th>Time</th>
                                    </tr>
                                </thead>
                                <tbody>`;

                    let rowNum = 1;
                    const sortedDates = Array.from(this.enabledTimeSlotsData.keys()).sort();

                    sortedDates.forEach((dateString) => {
                        const timesForDate = Array.from(this.enabledTimeSlotsData.get(dateString)).sort();
                        const timeRanges = groupTimeSlotsIntoRanges(timesForDate);

                        timeRanges.forEach((range) => {
                            html += `<tr>
                                        <td>${rowNum++}</td>
                                        <td>${dateString}</td>
                                        <td>${range}</td>
                                    </tr>`;
                        });
                    });

                    html += `</tbody></table>`;
                    this.savedTimesContainer.innerHTML = html;
                }

                // General Calendar specific actions
                addGeneralButtonListeners() {
                    document.getElementById("show-available-times-left").addEventListener("click", () => this.showAvailableDatesAndTimes());
                }

                showAvailableDatesAndTimes() {
                    // This function will fetch enabled times from the right calendar instance
                    // Assuming `calendarRight` is accessible globally or passed in some way.
                    // For simplicity, let's assume `calendarRight` is a global variable.
                    if (!window.calendarRight || window.calendarRight.enabledTimeSlotsData.size === 0) {
                        this.availableTimesContainer.innerHTML = "<h3>Available Dates & Times</h3><p>No available dates/times from Service Providers.</p>";
                        return;
                    }

                    const availableData = window.calendarRight.enabledTimeSlotsData;
                    let html = "<h3>Available Dates & Times</h3>";
                    html += `<table class="available-times-table">
                                <thead>
                                    <tr>
                                        <th>Select</th>
                                        <th>No.</th>
                                        <th>Date</th>
                                        <th>Time</th>
                                    </tr>
                                </thead>
                                <tbody>`;

                    let rowNum = 1;
                    const sortedDates = Array.from(availableData.keys()).sort();

                    sortedDates.forEach((dateString) => {
                        const timesForDate = Array.from(availableData.get(dateString)).sort(); // Individual times, not ranges for selection

                        timesForDate.forEach((time) => {
                            const uniqueId = `${dateString}-${time}`;
                            const isSelected = this.selectedTimeSlots.has(dateString) && this.selectedTimeSlots.get(dateString).has(time);
                            html += `<tr>
                                        <td><input type="checkbox" data-date="${dateString}" data-time="${time}" ${isSelected ? 'checked' : ''}></td>
                                        <td>${rowNum++}</td>
                                        <td>${dateString}</td>
                                        <td>${time}</td>
                                    </tr>`;
                        });
                    });

                    html += `</tbody></table>`;
                    this.availableTimesContainer.innerHTML = html;

                    // Add event listeners for checkboxes
                    this.availableTimesContainer.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
                        checkbox.addEventListener('change', (event) => {
                            const date = event.target.dataset.date;
                            const time = event.target.dataset.time;
                            if (event.target.checked) {
                                // Add to selected time slots for General calendar
                                if (!this.selectedTimeSlots.has(date)) {
                                    this.selectedTimeSlots.set(date, new Set());
                                }
                                this.selectedTimeSlots.get(date).add(time);
                            } else {
                                // Remove from selected time slots for General calendar
                                if (this.selectedTimeSlots.has(date)) {
                                    this.selectedTimeSlots.get(date).delete(time);
                                    if (this.selectedTimeSlots.get(date).size === 0) {
                                        this.selectedTimeSlots.delete(date);
                                    }
                                }
                            }
                            // Re-render the time slots display to reflect changes in selection
                            this.renderTimeSlots();
                        });
                    });
                }
            }

            // Initialize calendars
            const calendarLeft = new Calendar(
                "calendar-left",
                "start-date-left",
                "end-date-left",
                "apply-range-left",
                "reset-left",
                "deselect-time-left",
                "time-slots-left",
                false // Not a service provider calendar
            );
            const calendarRight = new Calendar(
                "calendar-right",
                "start-date-right",
                "end-date-right",
                "apply-range-right",
                "reset-right",
                "deselect-time-right",
                "time-slots-right",
                true // This is the service provider calendar
            );

            // Make calendarRight accessible globally for calendarLeft to reference
            window.calendarRight = calendarRight;
        </script>
    </body>
</html>