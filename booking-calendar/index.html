<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>Dual Calendar with Actions</title>
        <style>
            :root {
                --primary: #4f46e5;
                --accent: #fbbf24;
                --background: #f9fafb;
                --text: #111827;
                --disabled: #d1d5db;
                --today: #3b82f6;
                --selected: #8b5cf6;
                --weekend-bg: #fef2f2;
                --green: #10b981;
                --green-dark: #047857;
                --red: #ef4444;
                --blue: #3b82f6;
                --grey: #6b7280;
                --violet: #8b5cf6;
                --yellow: #f59e0b;
            }

            body {
                margin: 0;
                font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
                background: var(--background);
                color: var(--text);
            }

            .container {
                display: flex;
                flex-wrap: wrap;
                min-height: 100vh;
            }

            .side {
                flex: 1 1 100%;
                padding: 1.5rem;
                box-sizing: border-box;
                text-align: center;
            }

            @media (min-width: 768px) {
                .side {
                    flex: 1 1 50%;
                    border-right: 1px solid #e5e7eb;
                }

                .side:last-child {
                    border-right: none;
                }
            }

            .title {
                font-size: 1.5rem;
                margin-bottom: 1rem;
                font-weight: 600;
                text-align: center;
            }

            .calendar {
                background: white;
                border-radius: 12px;
                padding: 1rem;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
                max-width: 400px;
                margin: 0 auto 1rem auto;
            }

            .calendar-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 1rem;
            }

            .calendar-header button {
                background: var(--primary);
                color: white;
                border: none;
                padding: 0.3rem 0.6rem;
                border-radius: 6px;
                font-size: 0.9rem;
                cursor: pointer;
            }

            .calendar-header button:disabled {
                background: var(--disabled);
                cursor: not-allowed;
            }

            .calendar-header div {
                font-weight: 600;
                font-size: 1rem;
            }

            .calendar-grid {
                display: grid;
                grid-template-columns: repeat(7, 1fr);
                gap: 0.4rem;
            }

            .day-name {
                text-align: center;
                font-weight: 600;
                font-size: 0.85rem;
                color: var(--text); /* Default to dark color for all day names */
            }

            .day-name.weekend-text {
                color: var(--red); /* Override for weekend day names */
            }

            .day {
                text-align: center;
                padding: 0.6rem;
                border-radius: 8px;
                cursor: pointer;
                background: var(--background);
                font-weight: 500;
            }

            .day:hover:not(.disabled):not(.selected) {
                background: #e5e7eb;
            }

            .today {
                background: var(--today);
                color: white;
                font-weight: bold;
            }

            .selected {
                background: var(--selected);
                color: white;
            }

            /* New rule for red weekend day numbers */
            .day.weekend-day-number {
                color: var(--red);
            }

            /* Ensure selected and disabled states override the red weekend number */
            .day.selected.weekend-day-number,
            .day.selected {
                color: white; /* Selected days always white text */
            }

            .day.disabled,
            .day.disabled .weekend-day-number {
                /* Ensure disabled days have grey text */
                color: #9ca3af;
                cursor: not-allowed;
            }
            .day.disabled:hover {
                background: var(--background); /* Keep background same for disabled on hover */
            }

            .weekend {
                background-color: var(--weekend-bg);
            }

            .weekend:hover:not(.disabled):not(.selected) {
                background-color: #fbd5d5;
            }

            .day.next-month-day {
                color: var(--disabled);
                background: #f4f5f7;
            }

            .weekend.selected {
                background-color: var(--selected);
                color: white;
            }

            .buttons {
                display: flex;
                flex-wrap: wrap;
                justify-content: center;
                gap: 0.4rem;
            }

            .buttons button {
                padding: 0.4rem 0.8rem;
                border: none;
                border-radius: 6px;
                font-size: 0.85rem;
                color: white;
                cursor: pointer;
            }

            .btn-yellow {
                background-color: var(--accent);
            }
            .btn-blue {
                background-color: var(--blue);
            }
            .btn-green {
                background-color: var(--green);
            }
            .btn-grey {
                background-color: var(--grey);
            }
            .btn-red {
                background-color: var(--red);
            }
            .btn-violet {
                background-color: var(--violet);
            }
            .btn-green-dark {
                background-color: var(--green-dark);
            }

            /* New styles for date range inputs */
            .date-range-controls {
                margin-top: 1rem;
                display: flex;
                flex-wrap: wrap;
                justify-content: center;
                gap: 0.5rem;
                align-items: center;
                padding: 0.5rem;
                border-radius: 8px;
                background-color: white;
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.03);
            }

            .date-range-controls label {
                font-size: 0.9rem;
                font-weight: 500;
                color: var(--text);
            }

            .date-range-controls input[type="date"] {
                padding: 0.4rem;
                border: 1px solid #d1d5db;
                border-radius: 6px;
                font-size: 0.9rem;
                color: var(--text);
                flex-grow: 1; /* Allow inputs to grow */
                max-width: 150px; /* Max width for inputs */
            }

            .date-range-controls button {
                padding: 0.4rem 0.8rem;
                border: none;
                border-radius: 6px;
                font-size: 0.85rem;
                color: white;
                cursor: pointer;
                background-color: var(--blue); /* Using existing blue for apply button */
            }

            /* Styles for time slots */
            .time-slots-container {
                margin-top: 1rem;
                padding: 1rem;
                background: white;
                border-radius: 12px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
                max-width: 100%;
                margin-left: auto;
                margin-right: auto;
                text-align: left;
            }

            .time-slots-container h3 {
                text-align: center;
                margin-bottom: 1rem;
                color: var(--primary);
            }

            .time-slots-grid {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
                gap: 0.5rem;
            }

            .time-slot {
                padding: 0.5rem;
                border: 1px solid var(--primary);
                border-radius: 6px;
                text-align: center;
                cursor: pointer;
                background-color: var(--background);
                color: var(--text);
                font-weight: 500;
            }

            .time-slot:hover {
                background-color: var(--primary);
                color: white;
            }

            .time-slot.selected-time {
                background-color: var(--selected);
                color: white;
                border-color: var(--selected);
            }

            .day-time-slot-group {
                margin-bottom: 1rem;
                border-top: 1px solid #eee;
                padding-top: 0.5rem;
            }

            .day-time-slot-group:first-child {
                border-top: none;
                padding-top: 0;
            }

            .day-time-slot-group h4 {
                margin-top: 0.5rem;
                margin-bottom: 0.8rem;
                color: var(--blue);
                text-align: left;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div class="side">
                <div class="title">General</div>
                <div class="calendar" id="calendar-left"></div>
                <div class="buttons">
                    <button class="btn-yellow">Calculate Price</button>
                    <button class="btn-blue">Book Reservation</button>
                    <button class="btn-green">Show Available Dates and Times</button>
                    <button class="btn-grey" id="reset-left">Reset Selection</button>
                    <button class="btn-grey" id="deselect-time-left">Deselect time</button>
                </div>
                <div class="date-range-controls">
                    <label for="start-date-left">From:</label>
                    <input type="date" id="start-date-left" />
                    <label for="end-date-left">To:</label>
                    <input type="date" id="end-date-left" />
                    <button id="apply-range-left">Apply Range</button>
                </div>
                <div class="time-slots-container" id="time-slots-left"></div>
            </div>
            <div class="side">
                <div class="title">Service Providers</div>
                <div class="calendar" id="calendar-right"></div>
                <div class="buttons">
                    <button class="btn-green">Enable</button>
                    <button class="btn-grey">Disable</button>
                    <button class="btn-blue">Edit</button>
                    <button class="btn-red">Delete</button>
                    <button class="btn-violet">Cancel</button>
                    <button class="btn-green-dark">Accept</button>
                    <button class="btn-yellow">Busy</button>
                    <button class="btn-grey" id="reset-right">Reset Selection</button>
                    <button class="btn-grey" id="deselect-time-right">Deselect time</button>
                </div>
                <div class="date-range-controls">
                    <label for="start-date-right">From:</label>
                    <input type="date" id="start-date-right" />
                    <label for="end-date-right">To:</label>
                    <input type="date" id="end-date-right" />
                    <button id="apply-range-right">Apply Range</button>
                </div>
                <div class="time-slots-container" id="time-slots-right"></div>
            </div>
        </div>

        <script>
            // Utility function to format dates as YYYY-MM-DD
            function getFormattedDate(date) {
                const year = date.getUTCFullYear(); // Use UTC methods
                const month = (date.getUTCMonth() + 1).toString().padStart(2, "0");
                const day = date.getUTCDate().toString().padStart(2, "0");
                return `${year}-${month}-${day}`;
            }

            // Utility function to parse YYYY-MM-DD string to Date object (UTC)
            function parseDateString(dateString) {
                const [year, month, day] = dateString.split("-").map(Number);
                // Create Date object using UTC constructor for consistency
                return new Date(Date.UTC(year, month - 1, day));
            }

            class Calendar {
                constructor(
                    containerId,
                    startDateInputId,
                    endDateInputId,
                    applyButtonId,
                    resetButtonId,
                    deselectTimeButtonId, // New parameter for deselect time button
                    timeSlotsContainerId
                ) {
                    this.container = document.getElementById(containerId);
                    this.startDateInput = document.getElementById(startDateInputId);
                    this.endDateInput = document.getElementById(endDateInputId);
                    this.applyButton = document.getElementById(applyButtonId);
                    this.resetButton = document.getElementById(resetButtonId);
                    this.deselectTimeButton = document.getElementById(deselectTimeButtonId); // Get the deselect time button
                    this.timeSlotsContainer = document.getElementById(timeSlotsContainerId);

                    // Initialize currentDate using UTC components of 'now' for consistent internal state
                    const now = new Date();
                    this.currentDate = new Date(Date.UTC(now.getFullYear(), now.getMonth(), 1));

                    this.selectedDates = new Set(); // Each calendar has its own set of selected dates (formatted YYYY-MM-DD strings)
                    this.selectedTimeSlots = new Map(); // Map: 'YYYY-MM-DD' -> Set<timeString>
                    this.firstClickedDate = null; // Stores the Date object of the first click for range selection

                    this.todayFormatted = getFormattedDate(
                        new Date(Date.UTC(now.getFullYear(), now.getMonth(), now.getDate()))
                    );

                    this.render(); // Initial render
                    this.addRangeInputListeners(); // Add listeners for the new range inputs
                    this.addDelegatedDayClickListeners(); // Add delegated listener for day clicks
                    this.addResetButtonListener(); // Add listener for the reset button
                    this.addDeselectTimeButtonListener(); // Add listener for the deselect time button
                    this.setMinDatesForInputs(); // Set initial min dates for date inputs
                    this.renderTimeSlots(); // Initial render of time slots container (empty)
                }

                setMinDatesForInputs() {
                    this.startDateInput.min = this.todayFormatted;
                    this.endDateInput.min = this.todayFormatted;
                }

                render() {
                    // Create 'now' Date object in UTC for consistent comparisons
                    const now = new Date();
                    const nowUTC = new Date(Date.UTC(now.getFullYear(), now.getMonth(), now.getDate()));

                    const year = this.currentDate.getUTCFullYear(); // Use UTC methods
                    const month = this.currentDate.getUTCMonth(); // Use UTC methods
                    const firstDay = new Date(Date.UTC(year, month, 1));
                    const lastDay = new Date(Date.UTC(year, month + 1, 0));
                    const daysInMonth = lastDay.getUTCDate(); // Use UTC method

                    let startDay = (firstDay.getUTCDay() + 6) % 7; // Adjust to make Monday the first day (0-6 -> Mon-Sun)

                    this.container.innerHTML = `
                        <div class="calendar-header">
                            <button class="prev">&lt;</button>
                            <div>${this.currentDate.toLocaleString("default", {
                                month: "long",
                                year: "numeric",
                                timeZone: "UTC",
                            })}</div>
                            <button class="next">&gt;</button>
                        </div>
                        <div class="calendar-grid"></div>
                    `;

                    const grid = this.container.querySelector(".calendar-grid");
                    const dayNames = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
                    dayNames.forEach((d, index) => {
                        const el = document.createElement("div");
                        el.className = "day-name";
                        if (index === 5 || index === 6) {
                            // Saturday (5) and Sunday (6)
                            el.classList.add("weekend-text");
                        }
                        el.textContent = d;
                        grid.appendChild(el);
                    });

                    // Fill leading empty days
                    for (let i = 0; i < startDay; i++) {
                        const empty = document.createElement("div");
                        grid.appendChild(empty);
                    }

                    // Render days of the current month
                    for (let day = 1; day <= daysInMonth; day++) {
                        const el = document.createElement("div");
                        el.className = "day";
                        el.textContent = day;

                        const cellDate = new Date(Date.UTC(year, month, day)); // Create Date object for cell in UTC
                        const cellDayOfWeek = (cellDate.getUTCDay() + 6) % 7; // 0=Mon, 1=Tue, ..., 5=Sat, 6=Sun
                        const isPast = cellDate.getTime() < nowUTC.getTime(); // Compare UTC dates using getTime()
                        const formattedCellDate = getFormattedDate(cellDate);

                        // Store the formatted date directly on the element for easy retrieval via event delegation
                        el.dataset.date = formattedCellDate;

                        if (cellDayOfWeek === 5 || cellDayOfWeek === 6) {
                            // Saturday or Sunday
                            el.classList.add("weekend", "weekend-day-number"); // Add weekend-day-number for red text
                        }

                        if (isPast) {
                            el.classList.add("disabled");
                        }

                        if (
                            cellDate.getUTCFullYear() === nowUTC.getUTCFullYear() &&
                            cellDate.getUTCMonth() === nowUTC.getUTCMonth() &&
                            cellDate.getUTCDate() === nowUTC.getUTCDate()
                        ) {
                            el.classList.add("today");
                        }

                        // Check if this day is selected for THIS calendar
                        if (this.selectedDates.has(formattedCellDate)) {
                            el.classList.add("selected");
                        }

                        grid.appendChild(el);
                    }

                    // Add days from the next month to fill the grid
                    const totalDaysDisplayed = startDay + daysInMonth;
                    let fillerDayCount = 0;

                    if (totalDaysDisplayed < 35) {
                        fillerDayCount = 35 - totalDaysDisplayed;
                    } else if (totalDaysDisplayed < 42) {
                        fillerDayCount = 42 - totalDaysDisplayed;
                    }

                    for (let day = 1; day <= fillerDayCount; day++) {
                        const el = document.createElement("div");
                        el.className = "day next-month-day";
                        el.textContent = day;

                        const nextMonthDate = new Date(Date.UTC(year, month + 1, day)); // Create UTC date
                        const formattedNextMonthDate = getFormattedDate(nextMonthDate);

                        // Store the formatted date directly on the element for easy retrieval
                        el.dataset.date = formattedNextMonthDate;

                        const cellDayOfWeek = (nextMonthDate.getUTCDay() + 6) % 7; // Get day of week for next month's day in UTC

                        if (cellDayOfWeek === 5 || cellDayOfWeek === 6) {
                            // Saturday or Sunday in the next month
                            el.classList.add("weekend", "weekend-day-number"); // Add weekend-day-number for red text
                        }

                        // Check if this next month day is selected for THIS calendar
                        if (this.selectedDates.has(formattedNextMonthDate)) {
                            el.classList.add("selected");
                        }

                        grid.appendChild(el);
                    }

                    // After rendering the new buttons, attach their event listeners, including delegated day clicks
                    this.addEventListeners();
                    this.addDelegatedDayClickListeners(); // Ensure this is called after the grid is rendered

                    // Disable previous button if at current month (using UTC components)
                    const prevButton = this.container.querySelector(".prev");
                    if (
                        this.currentDate.getUTCFullYear() === nowUTC.getUTCFullYear() &&
                        this.currentDate.getUTCMonth() === nowUTC.getUTCMonth()
                    ) {
                        prevButton.disabled = true;
                    } else {
                        prevButton.disabled = false;
                    }

                    this.updateDateInputs(); // Update the input fields after rendering
                    this.renderTimeSlots(); // Re-render time slots based on updated selected dates
                }

                addEventListeners() {
                    // Remove any existing listeners first to prevent duplicates by cloning nodes
                    const prevButton = this.container.querySelector(".prev");
                    const nextButton = this.container.querySelector(".next");

                    const newPrevButton = prevButton.cloneNode(true);
                    const newNextButton = nextButton.cloneNode(true);

                    prevButton.parentNode.replaceChild(newPrevButton, prevButton);
                    nextButton.parentNode.replaceChild(newNextButton, nextButton);

                    // Re-attach event listeners to the new buttons
                    newPrevButton.addEventListener("click", () => {
                        const now = new Date();
                        const nowUTC = new Date(Date.UTC(now.getFullYear(), now.getMonth(), now.getDate()));
                        // Prevent going back before the current month (using UTC components)
                        if (
                            this.currentDate.getUTCFullYear() > nowUTC.getUTCFullYear() ||
                            (this.currentDate.getUTCFullYear() === nowUTC.getUTCFullYear() &&
                                this.currentDate.getUTCMonth() > nowUTC.getUTCMonth())
                        ) {
                            this.currentDate.setUTCMonth(this.currentDate.getUTCMonth() - 1);
                            this.render();
                        }
                    });

                    newNextButton.addEventListener("click", () => {
                        this.currentDate.setUTCMonth(this.currentDate.getUTCMonth() + 1);
                        this.render();
                    });
                }

                /**
                 * Attaches a single delegated click listener to the calendar grid for all day elements.
                 * This listener will persist even when the grid content is re-rendered.
                 */
                addDelegatedDayClickListeners() {
                    const calendarGrid = this.container.querySelector(".calendar-grid");

                    // Define the handler function once in the constructor if not already defined
                    if (!this._dayClickHandler) {
                        this._dayClickHandler = (event) => {
                            const clickedDayElement = event.target.closest(".day");

                            if (clickedDayElement && !clickedDayElement.classList.contains("disabled")) {
                                const formattedDate = clickedDayElement.dataset.date;

                                // If a next-month-day was clicked, we need to first navigate to that month
                                if (clickedDayElement.classList.contains("next-month-day")) {
                                    const nextMonthDate = parseDateString(formattedDate);
                                    this.currentDate = new Date(
                                        Date.UTC(nextMonthDate.getUTCFullYear(), nextMonthDate.getUTCMonth(), 1)
                                    );
                                }

                                this.handleDayClick(formattedDate);
                            }
                        };
                    }

                    // Remove previous listener instance if it exists (important for re-renders)
                    if (calendarGrid) {
                        calendarGrid.removeEventListener("click", this._dayClickHandler);
                        calendarGrid.addEventListener("click", this._dayClickHandler);
                    }
                }

                /**
                 * Handles a click on a day cell to implement single day or range selection, and unselection.
                 * If a day within an existing range is clicked, it clears the current range and starts a new single-day selection.
                 * @param {string} formattedDate The 'YYYY-MM-DD' string of the clicked date.
                 */
                handleDayClick(formattedDate) {
                    const clickedDate = parseDateString(formattedDate);
                    const now = new Date();
                    const nowUTC = new Date(Date.UTC(now.getFullYear(), now.getMonth(), now.getDate()));

                    if (clickedDate.getTime() < nowUTC.getTime()) {
                        // Should already be disabled, but a safety check for clicks.
                        alert("Cannot select a past date.");
                        return;
                    }

                    if (!this.firstClickedDate) {
                        // This is the very first click or after a reset. Select this date as the start of a range.
                        this.selectedDates.clear();
                        this.selectedDates.add(formattedDate);
                        this.firstClickedDate = clickedDate;
                    } else {
                        // This is the second click for a potential range selection.
                        const secondDate = clickedDate;

                        if (secondDate.getTime() < this.firstClickedDate.getTime()) {
                            // User tried to select a range backwards (e.g., selected 21st, then 19th).
                            // As per cargo.lt behavior, this should reset the selection to the new single date.
                            this.selectedDates.clear();
                            this.selectedDates.add(formattedDate);
                            this.firstClickedDate = clickedDate; // The earlier date becomes the new first clicked date
                        } else {
                            // Valid forward range selection.
                            this.selectedDates.clear();
                            let loopDate = new Date(this.firstClickedDate);
                            while (loopDate.getTime() <= secondDate.getTime()) {
                                this.selectedDates.add(getFormattedDate(loopDate));
                                loopDate.setUTCDate(loopDate.getUTCDate() + 1);
                            }
                            // After completing a range selection, reset firstClickedDate
                            this.firstClickedDate = null;
                        }
                    }
                    this.render(); // Re-render to update the calendar display and input fields
                }

                addRangeInputListeners() {
                    if (this.applyButton) {
                        this.applyButton.addEventListener("click", () => this.handleApplyRange());
                    }
                    // Add input change listeners to update selections
                    if (this.startDateInput) {
                        this.startDateInput.addEventListener("change", () => this.handleDateInputChange());
                    }
                    if (this.endDateInput) {
                        this.endDateInput.addEventListener("change", () => this.handleDateInputChange());
                    }
                }

                addResetButtonListener() {
                    // Add event listener for the reset button
                    if (this.resetButton) {
                        this.resetButton.addEventListener("click", () => this.resetSelection());
                    }
                }

                // New method to handle deselecting all time slots
                addDeselectTimeButtonListener() {
                    if (this.deselectTimeButton) {
                        this.deselectTimeButton.addEventListener("click", () => this.deselectTimeSlots());
                    }
                }

                deselectTimeSlots() {
                    this.selectedTimeSlots.clear(); // Clear all selected time slots
                    this.renderTimeSlots(); // Re-render the time slots display
                }

                handleDateInputChange() {
                    const startDateStr = this.startDateInput.value;
                    const endDateStr = this.endDateInput.value;

                    const now = new Date();
                    const nowUTC = new Date(Date.UTC(now.getFullYear(), now.getMonth(), now.getDate())); // Today's date in UTC

                    // Update endDateInput's min attribute based on startDateInput's value
                    if (startDateStr) {
                        this.endDateInput.min = startDateStr;
                    } else {
                        // If start date is cleared, min for end date reverts to today
                        this.endDateInput.min = this.todayFormatted;
                    }

                    if (startDateStr && endDateStr) {
                        const startDate = parseDateString(startDateStr);
                        const endDate = parseDateString(endDateStr);

                        if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
                            // Invalid date format, just return without changing selection
                            return;
                        }

                        // Check if either date is in the past
                        if (startDate.getTime() < nowUTC.getTime() || endDate.getTime() < nowUTC.getTime()) {
                            alert("Cannot select a past date. Selection reset.");
                            this.resetSelection();
                            return;
                        }

                        if (endDate.getTime() < startDate.getTime()) {
                            // Compare using getTime() for Date objects
                            alert("End date cannot be before start date. Selection reset.");
                            this.resetSelection();
                            return;
                        }
                        this.applyDateRange(startDate, endDate, true); // true to prevent re-rendering if already on correct month
                    } else if (!startDateStr && !endDateStr) {
                        this.resetSelection(); // If both cleared, reset calendar
                    } else {
                        // If only one date is set, consider it a single selection
                        if (startDateStr) {
                            const startDate = parseDateString(startDateStr);
                            if (startDate.getTime() < nowUTC.getTime()) {
                                alert("Cannot select a past date. Selection reset.");
                                this.resetSelection();
                                return;
                            }
                            this.selectedDates.clear();
                            this.selectedDates.add(startDateStr);
                            this.firstClickedDate = null; // Clear firstClickedDate for single selection
                            this.currentDate = new Date(Date.UTC(startDate.getUTCFullYear(), startDate.getUTCMonth(), 1)); // Move to the selected month
                            this.render();
                        } else if (endDateStr) {
                            // If only end date is set, treat it as a single selection
                            const endDate = parseDateString(endDateStr);
                            if (endDate.getTime() < nowUTC.getTime()) {
                                alert("Cannot select a past date. Selection reset.");
                                this.resetSelection();
                                return;
                            }
                            this.selectedDates.clear();
                            this.selectedDates.add(endDateStr);
                            this.firstClickedDate = null; // Clear firstClickedDate for single selection
                            this.currentDate = new Date(Date.UTC(endDate.getUTCFullYear(), endDate.getUTCMonth(), 1)); // Move to the selected month
                            this.render();
                        }
                    }
                }

                handleApplyRange() {
                    const startDateStr = this.startDateInput.value;
                    const endDateStr = this.endDateInput.value;

                    const now = new Date();
                    const nowUTC = new Date(Date.UTC(now.getFullYear(), now.getMonth(), now.getDate()));

                    if (!startDateStr || !endDateStr) {
                        alert("Please select both start and end dates to apply a range.");
                        return;
                    }

                    const startDate = parseDateString(startDateStr);
                    const endDate = parseDateString(endDateStr);

                    if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
                        alert("Invalid date format. Please use YYYY-MM-DD.");
                        return;
                    }

                    // Check if either date is in the past
                    if (startDate.getTime() < nowUTC.getTime() || endDate.getTime() < nowUTC.getTime()) {
                        alert("Cannot select a past date.");
                        this.resetSelection();
                        return;
                    }

                    if (endDate.getTime() < startDate.getTime()) {
                        alert("End date cannot be before start date.");
                        this.resetSelection();
                        return;
                    }

                    this.applyDateRange(startDate, endDate);
                }

                applyDateRange(startDate, endDate, suppressRender = false) {
                    this.selectedDates.clear();
                    let loopDate = new Date(startDate);
                    while (loopDate.getTime() <= endDate.getTime()) {
                        this.selectedDates.add(getFormattedDate(loopDate));
                        loopDate.setUTCDate(loopDate.getUTCDate() + 1);
                    }
                    this.firstClickedDate = null; // Clear firstClickedDate after range selection
                    // Set calendar to display the start month of the selected range
                    this.currentDate = new Date(Date.UTC(startDate.getUTCFullYear(), startDate.getUTCMonth(), 1));
                    if (!suppressRender) {
                        this.render();
                    } else {
                        // If render is suppressed, ensure the visual selection is updated
                        this.updateCalendarDayClasses();
                        this.renderTimeSlots();
                    }
                }

                updateCalendarDayClasses() {
                    this.container.querySelectorAll(".day").forEach((dayEl) => {
                        const formattedDate = dayEl.dataset.date;
                        if (this.selectedDates.has(formattedDate)) {
                            dayEl.classList.add("selected");
                        } else {
                            dayEl.classList.remove("selected");
                        }
                    });
                }

                updateDateInputs() {
                    const sortedSelectedDates = Array.from(this.selectedDates).sort();
                    if (sortedSelectedDates.length > 0) {
                        this.startDateInput.value = sortedSelectedDates[0];
                        this.endDateInput.value = sortedSelectedDates[sortedSelectedDates.length - 1];
                    } else {
                        this.startDateInput.value = "";
                        this.endDateInput.value = "";
                    }
                }

                resetSelection() {
                    this.selectedDates.clear();
                    this.selectedTimeSlots.clear(); // Also clear selected time slots on date reset
                    this.firstClickedDate = null;
                    const now = new Date();
                    this.currentDate = new Date(Date.UTC(now.getFullYear(), now.getMonth(), 1)); // Reset to current month
                    this.render(); // Re-render to clear selection and update inputs
                    this.startDateInput.value = "";
                    this.endDateInput.value = "";
                }

                // Generates and renders time slots based on the currently selected dates.
                renderTimeSlots() {
                    let html = "<h3>Selected Dates & Times</h3>";

                    if (this.selectedDates.size === 0) {
                        this.timeSlotsContainer.innerHTML = html + "<p>No dates selected yet.</p>";
                        return;
                    }

                    // Sort selected dates to display them in chronological order
                    const sortedDates = Array.from(this.selectedDates).sort();

                    sortedDates.forEach((dateString) => {
                        html += `<div class="day-time-slot-group">`;
                        html += `<h4>${new Date(dateString).toLocaleDateString("en-US", {
                            weekday: "short",
                            year: "numeric",
                            month: "short",
                            day: "numeric",
                            timeZone: "UTC",
                        })}</h4>`;
                        html += `<div class="time-slots-grid">`;

                        // Example time slots - replace with dynamic data as needed
                        const times = [
                            "09:00",
                            "10:00",
                            "11:00",
                            "12:00",
                            "13:00",
                            "14:00",
                            "15:00",
                            "16:00",
                            "17:00",
                        ];

                        times.forEach((time) => {
                            const isSelected = this.selectedTimeSlots.has(dateString) &&
                                this.selectedTimeSlots.get(dateString).has(time);
                            html += `<div class="time-slot ${isSelected ? 'selected-time' : ''}" data-date="${dateString}" data-time="${time}">${time}</div>`;
                        });
                        html += `</div></div>`;
                    });

                    this.timeSlotsContainer.innerHTML = html;
                    this.addTimeSlotClickListeners(); // Add listeners after rendering
                }

                // Attaches click listeners to each time slot.
                addTimeSlotClickListeners() {
                    this.timeSlotsContainer.querySelectorAll(".time-slot").forEach((slot) => {
                        slot.addEventListener("click", (event) => {
                            const dateString = event.target.dataset.date;
                            const timeString = event.target.dataset.time;
                            this.toggleTimeSlotSelection(dateString, timeString);
                        });
                    });
                }

                // Toggles the selection state of a time slot.
                toggleTimeSlotSelection(dateString, timeString) {
                    if (!this.selectedTimeSlots.has(dateString)) {
                        this.selectedTimeSlots.set(dateString, new Set());
                    }

                    const timeSet = this.selectedTimeSlots.get(dateString);
                    if (timeSet.has(timeString)) {
                        timeSet.delete(timeString);
                        if (timeSet.size === 0) {
                            this.selectedTimeSlots.delete(dateString); // Remove date if no times selected for it
                        }
                    } else {
                        timeSet.add(timeString);
                    }
                    this.renderTimeSlots(); // Re-render to update UI
                }
            }

            // Initialize calendars
            const calendarLeft = new Calendar(
                "calendar-left",
                "start-date-left",
                "end-date-left",
                "apply-range-left",
                "reset-left",
                "deselect-time-left",
                "time-slots-left"
            );
            const calendarRight = new Calendar(
                "calendar-right",
                "start-date-right",
                "end-date-right",
                "apply-range-right",
                "reset-right",
                "deselect-time-right",
                "time-slots-right"
            );
        </script>
    </body>
</html>